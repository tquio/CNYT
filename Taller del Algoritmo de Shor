{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Taller del Algoritmo de Shor: Resumen Completo"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Introducción\n",
    "\n",
    "El algoritmo de Shor, propuesto por Peter Shor en 1994, es un algoritmo cuántico diseñado para la factorización de enteros. Dado un entero $N$, el algoritmo encuentra sus factores primos. Su importancia radica en que tiene una complejidad temporal polinómica, lo que lo hace significativamente más rápido que los algoritmos clásicos más conocidos, cuya complejidad es superpolinómica. Esta eficiencia representa una amenaza potencial para sistemas de encriptación como RSA, que basan su seguridad en la dificultad de factorizar números grandes.\n",
    "\n",
    "Este taller introduce los fundamentos del algoritmo de Shor, explora sus bases en la mecánica cuántica (aunque se centra más en la parte clásica en el notebook) y muestra cómo se implementaría conceptualmente."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Aritmética Modular\n",
    "\n",
    "La aritmética modular es fundamental para el algoritmo de Shor. Trata con los restos de las divisiones.\n",
    "\n",
    "Dados dos números naturales $N$ y $a$, con $a < N$:\n",
    "La expresión $a \\pmod N$ (o $a \\% N$ en muchos lenguajes de programación) representa el resto de la división de $a$ entre $N$.\n",
    "\n",
    "**Ejemplos del notebook:**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Ejemplo de módulo básico\n",
    "remainder = 10 % 3\n",
    "print(f\"10 mod 3 = {remainder}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Ejemplo de módulo con números negativos\n",
    "negative_modulo_1 = -1 % 371\n",
    "print(f\"-1 mod 371 = {negative_modulo_1}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Ejemplo de módulo con cero\n",
    "zero_modulo = 0 % 371\n",
    "print(f\"0 mod 371 = {zero_modulo}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Congruencia\n",
    "\n",
    "Dos enteros $a$ y $b$ se dicen **congruentes módulo $N$**, y se escribe como $a \\equiv b \\pmod N$, si y solo si $(a \\pmod N) = (b \\pmod N)$.\n",
    "Esto es equivalente a decir que $N$ divide a la diferencia $(a-b)$, es decir, $a-b = kN$ para algún entero $k$.\n",
    "\n",
    "**Ejemplos del notebook:**\n",
    "* $17 \\equiv 2 \\pmod{15}$:\n",
    "    * $17 \\pmod{15} = 2$\n",
    "    * $2 \\pmod{15} = 2$\n",
    "    * Alternativamente, $17 - 2 = 15$, y $15$ es divisible por $15$.\n",
    "* $534 \\equiv 1479 \\pmod{15}$:\n",
    "    * $534 = 35 \\times 15 + 9 \\implies 534 \\pmod{15} = 9$\n",
    "    * $1479 = 98 \\times 15 + 9 \\implies 1479 \\pmod{15} = 9$\n",
    "    * Alternativamente, $534 - 1479 = -945$, y $-945 / 15 = -63$.\n",
    "* $3350 \\equiv 2237 \\pmod{371}$:\n",
    "    * $3350 = 9 \\times 371 + 11 \\implies 3350 \\pmod{371} = 11$\n",
    "    * $2237 = 6 \\times 371 + 11 \\implies 2237 \\pmod{371} = 11$\n",
    "    * Alternativamente, $3350 - 2237 = 1113$, y $1113 / 371 = 3$.\n",
    "\n",
    "**Ejercicios de Congruencia (resueltos):**\n",
    "\n",
    "1.  **Demostrar que $1977 \\equiv 1 \\pmod{247}$:**\n",
    "    Debemos verificar si $247$ divide a $(1977 - 1)$.\n",
    "    $1977 - 1 = 1976$.\n",
    "    $1976 / 247 = 8$.\n",
    "    Como la división es exacta (el resultado es un entero), la congruencia $1977 \\equiv 1 \\pmod{247}$ es **verdadera**.\n",
    "\n",
    "2.  **Demostrar que $16183 \\equiv 15442 \\pmod{247}$:**\n",
    "    Debemos verificar si $247$ divide a $(16183 - 15442)$.\n",
    "    $16183 - 15442 = 741$.\n",
    "    $741 / 247 = 3$.\n",
    "    Como la división es exacta, la congruencia $16183 \\equiv 15442 \\pmod{247}$ es **verdadera**."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Exponenciación Modular\n",
    "\n",
    "El objetivo del algoritmo de Shor es encontrar un factor de un número $N$.\n",
    "El procedimiento clásico (que la parte cuántica acelera) implica los siguientes pasos:\n",
    "\n",
    "1.  Elegir un entero aleatorio $a$ tal que $1 < a < N$.\n",
    "2.  Calcular el Máximo Común Divisor, $GCD(a, N)$.\n",
    "    * Si $GCD(a, N) \\neq 1$, entonces hemos encontrado un factor de $N$ (que es el propio $GCD$), y el proceso termina.\n",
    "    * Si $GCD(a, N) = 1$, entonces $a$ y $N$ son coprimos (o primos relativos). En este caso, $a$ es un buen candidato para continuar con el algoritmo.\n",
    "\n",
    "3.  Si $a$ y $N$ son coprimos, se define la función $f_{a,N}(x) = a^x \\pmod N$. Se calcula esta función para valores de $x = 0, 1, 2, \\dots$. Esta secuencia es periódica.\n",
    "\n",
    "**Ejemplo del notebook (N=15, a=2):**\n",
    "El código Python `powersAModuloN(a,N)` calcula $a^i \\pmod N$ para $i$ desde $0$ hasta $N-1$.\n",
    "Para $N=15, a=2$:\n",
    "`powers_a_N = [1, 2, 4, 8, 1, 2, 4, 8, 1, 2, 4, 8, 1, 2, 4]`\n",
    "La función `periodoDeF(a,N)` busca el primer `1` en la secuencia (después del inicial $a^0=1$).\n",
    "El periodo $r$ es $4$, ya que $2^4 \\equiv 16 \\equiv 1 \\pmod{15}$.\n",
    "La secuencia de valores es $(1, 2, 4, 8)$, que se repite.\n",
    "\n",
    "**Otros ejemplos del notebook:**\n",
    "* $N=15, a=4$: `powers_a_N = [1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1]`. Periodo $r=2$. ($4^2 = 16 \\equiv 1 \\pmod{15}$).\n",
    "* $N=15, a=13$: `powers_a_N = [1, 13, 4, 7, 1, 13, 4, 7, 1, 13, 4, 7, 1, 13, 4]`. Periodo $r=4$. ($13^2 \\equiv (-2)^2 \\equiv 4 \\pmod{15}$; $13^4 \\equiv 4^2 \\equiv 16 \\equiv 1 \\pmod{15}$).\n",
    "* $N=371, a=2$: El periodo es $r=132$."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "\n",
    "def powersAModuloN(a, N):\n",
    "    \"\"\"Calcula a^i mod N para i desde 0 hasta N-1.\"\"\"\n",
    "    powers = []\n",
    "    if N == 0:\n",
    "        return []\n",
    "    for i in range(N):\n",
    "        powers.append(pow(a, i, N)) # Usando pow(a, i, N) para eficiencia y corrección\n",
    "    return powers\n",
    "\n",
    "def periodoDeF(a, N, powers_list=None):\n",
    "    \"\"\"Encuentra el periodo r tal que a^r = 1 (mod N).\"\"\"\n",
    "    if N <= 1: # El periodo no está bien definido para N <=1\n",
    "        return -1\n",
    "    if powers_list is None:\n",
    "        powers_list = powersAModuloN(a, N)\n",
    "    try:\n",
    "        # Encuentra la primera ocurrencia de 1 después del índice 0 (a^0 = 1)\n",
    "        return powers_list.index(1, 1)\n",
    "    except ValueError:\n",
    "        # Esto puede ocurrir si 'a' no es coprimo con N o si N es muy pequeño.\n",
    "        # O si la lista no es lo suficientemente larga (aunque powersAModuloN genera N elementos)\n",
    "        return -1 # Indica que el periodo no fue encontrado con las condiciones dadas\n",
    "\n",
    "def computeAndDrawPowersAModuloN(a, N):\n",
    "    \"\"\"Calcula, imprime y grafica las potencias modulares y el periodo.\"\"\"\n",
    "    print(f\"Calculando para N={N}, a={a}\")\n",
    "    powers_a_N = powersAModuloN(a,N)\n",
    "    period = periodoDeF(a, N, powers_a_N)\n",
    "    print(f\"Periodo: {period}\")\n",
    "\n",
    "    # Limitar el rango de la gráfica si N es muy grande para mejor visualización\n",
    "    plot_range = N\n",
    "    display_limit = 50 # Mostrar hasta 50 puntos en la gráfica como máximo por defecto\n",
    "    if N > display_limit:\n",
    "        print(f\"N={N} es grande, mostrando hasta x={display_limit-1} en la gráfica si el periodo es mayor.\")\n",
    "        plot_range = display_limit\n",
    "    \n",
    "    # Ajustar el rango de la gráfica para mostrar al menos dos ciclos si el periodo es corto\n",
    "    if period != -1 and period * 2 < plot_range:\n",
    "        actual_plot_up_to = min(N, period * 2)\n",
    "    elif period != -1 and period < plot_range:\n",
    "        actual_plot_up_to = min(N, period + 1)\n",
    "    else:\n",
    "        actual_plot_up_to = min(N, plot_range)\n",
    "        \n",
    "    xpoints = np.array(range(actual_plot_up_to))\n",
    "    ypoints = np.array(powers_a_N[:actual_plot_up_to])\n",
    "\n",
    "    # Imprimir solo una parte de los datos si son muchos\n",
    "    print_limit = 20\n",
    "    print(f\"      x   = {xpoints[:print_limit]}... (mostrando hasta {len(xpoints)} puntos)\")\n",
    "    print(f\" f(x)_a_N = {ypoints[:print_limit]}...\")\n",
    "\n",
    "    if len(xpoints) > 0 : # Solo graficar si hay puntos\n",
    "        plt.figure(figsize=(12, 5))\n",
    "        plt.bar(xpoints, ypoints, width=0.8)\n",
    "        plt.title(f\"$f(x) = {a}^x \\pmod{{{N}}}$ (hasta x={actual_plot_up_to-1})\")\n",
    "        plt.xlabel(\"$x$\")\n",
    "        plt.ylabel(f\"${a}^x \\pmod{{{N}}}$\")\n",
    "        plt.xticks(xpoints) # Asegurar que todos los ticks de x se muestren si no son demasiados\n",
    "        if len(xpoints) > 30: # Si hay muchos puntos, dejar que matplotlib decida los ticks\n",
    "             plt.xticks(np.arange(0, actual_plot_up_to, step=max(1, actual_plot_up_to // 20)))\n",
    "        plt.grid(True, axis='y', linestyle='--')\n",
    "        plt.show()\n",
    "    else:\n",
    "        print(\"No hay puntos para graficar (N podría ser 0 o 1).\")\n",
    "\n",
    "# Ejemplo: N=15, a=2\n",
    "N_ex1 = 15\n",
    "a_ex1 = 2\n",
    "computeAndDrawPowersAModuloN(a_ex1, N_ex1)\n",
    "\n",
    "# Otros ejemplos mencionados en el resumen\n",
    "# N=15, a=4\n",
    "N_ex2 = 15\n",
    "a_ex2 = 4\n",
    "computeAndDrawPowersAModuloN(a_ex2, N_ex2)\n",
    "\n",
    "# N=15, a=13\n",
    "N_ex3 = 15\n",
    "a_ex3 = 13\n",
    "computeAndDrawPowersAModuloN(a_ex3, N_ex3)\n",
    "\n",
    "# N=371, a=2 (Solo imprimir periodo, la gráfica sería muy densa)\n",
    "N_ex4 = 371\n",
    "a_ex4 = 2\n",
    "powers_ex4 = powersAModuloN(a_ex4, N_ex4)\n",
    "period_ex4 = periodoDeF(a_ex4, N_ex4, powers_ex4)\n",
    "print(f\"\\nPara N={N_ex4}, a={a_ex4}, el periodo es: {period_ex4}\")\n",
    "# computeAndDrawPowersAModuloN(a_ex4, N_ex4) # Descomentar para dibujar, pero tener en cuenta la densidad."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Una forma más eficiente de calcular $f_{a,N}(x)$\n",
    "\n",
    "Calcular $a^x \\pmod N$ directamente puede ser costoso si $x$ es grande. Se puede usar la propiedad de la aritmética modular:\n",
    "$(A \\times B) \\pmod N = ((A \\pmod N) \\times (B \\pmod N)) \\pmod N$.\n",
    "Aplicado a la exponenciación:\n",
    "$a^x \\pmod N = (a^{x-1} \\times a) \\pmod N = ((a^{x-1} \\pmod N) \\times a) \\pmod N$.\n",
    "Esto lleva a una definición recursiva (o iterativa paso a paso):\n",
    "$f_{a,N}(0) = a^0 \\pmod N = 1$.\n",
    "$f_{a,N}(x) = (f_{a,N}(x-1) \\times a) \\pmod N$ para $x > 0$.\n",
    "\n",
    "El notebook original implementa esto en una función llamada `powersAModuloNRecursive`. Aquí la llamaremos `powersAModuloNIterativeStepByStep` para distinguirla y aclarar su naturaleza constructiva."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# La función powersAModuloN ya es eficiente usando pow(a,i,N).\n",
    "# La siguiente es para ilustrar la construcción iterativa paso a paso mencionada.\n",
    "def powersAModuloNIterativeStepByStep(a, N):\n",
    "    \"\"\"Calcula a^i mod N iterativamente, construyendo la lista paso a paso.\"\"\"\n",
    "    if N == 0: return []\n",
    "    powers = [1] # f(0) = a^0 mod N = 1 (asumiendo N > 1)\n",
    "    if N == 1: return powers # Para N=1, a^0 mod 1 = 0. pow(a,0,1) maneja esto. Aquí simplificamos.\n",
    "                      # De hecho, pow(a,0,1) es 0. Para N=1, el único residuo es 0.\n",
    "                      # Si N=1, powersAModuloN(a,1) devuelve [0].\n",
    "                      # Para mantener consistencia, si N=1, el resultado debería ser [0].\n",
    "    if N == 1:\n",
    "        return [0] # a^0 mod 1 = 0\n",
    "        \n",
    "    for i in range(1, N):\n",
    "        next_power = (powers[i-1] * a) % N\n",
    "        powers.append(next_power)\n",
    "    return powers\n",
    "\n",
    "# La función periodoDeF ya fue definida.\n",
    "# def periodoDeF(a, N, powers_list=None): ...\n",
    "\n",
    "def computeAndDrawPowersIterativeStepByStep(a, N):\n",
    "    \"\"\"Calcula (método iterativo paso a paso), imprime y grafica.\"\"\"\n",
    "    print(f\"Calculando (método iterativo paso a paso) para N={N}, a={a}\")\n",
    "    powers_a_N = powersAModuloNIterativeStepByStep(a,N)\n",
    "    \n",
    "    period = periodoDeF(a, N, powers_a_N)\n",
    "    print(f\"Periodo: {period}\")\n",
    "\n",
    "    # Lógica de graficación similar a computeAndDrawPowersAModuloN\n",
    "    plot_range = N\n",
    "    display_limit = 50\n",
    "    if N > display_limit:\n",
    "        print(f\"N={N} es grande, mostrando hasta x={display_limit-1} en la gráfica si el periodo es mayor.\")\n",
    "        plot_range = display_limit\n",
    "    \n",
    "    if period != -1 and period * 2 < plot_range:\n",
    "        actual_plot_up_to = min(N, period * 2)\n",
    "    elif period != -1 and period < plot_range:\n",
    "         actual_plot_up_to = min(N, period +1) # Asegurar que el primer 1 se incluya\n",
    "    else:\n",
    "        actual_plot_up_to = min(N, plot_range)\n",
    "\n",
    "    xpoints = np.array(range(actual_plot_up_to))\n",
    "    ypoints = np.array(powers_a_N[:actual_plot_up_to])\n",
    "\n",
    "    print_limit = 20\n",
    "    print(f\"      x   = {xpoints[:print_limit]}... (mostrando hasta {len(xpoints)} puntos)\")\n",
    "    print(f\" f(x)_a_N = {ypoints[:print_limit]}...\")\n",
    "\n",
    "    if len(xpoints) > 0:\n",
    "        plt.figure(figsize=(12, 5))\n",
    "        plt.bar(xpoints, ypoints, width=0.8)\n",
    "        plt.title(f\"$f(x) = {a}^x \\pmod{{{N}}}$ (Iterativo, hasta x={actual_plot_up_to-1})\")\n",
    "        plt.xlabel(\"$x$\")\n",
    "        plt.ylabel(f\"${a}^x \\pmod{{{N}}}$\")\n",
    "        plt.xticks(xpoints)\n",
    "        if len(xpoints) > 30:\n",
    "             plt.xticks(np.arange(0, actual_plot_up_to, step=max(1, actual_plot_up_to // 20)))\n",
    "        plt.grid(True, axis='y', linestyle='--')\n",
    "        plt.show()\n",
    "    else:\n",
    "        print(\"No hay puntos para graficar.\")\n",
    "\n",
    "# Ejemplos con el método iterativo paso a paso\n",
    "# N=371, a=24\n",
    "N_ex_iter1 = 371\n",
    "a_ex_iter1 = 24\n",
    "powers_ex_iter1 = powersAModuloNIterativeStepByStep(a_ex_iter1, N_ex_iter1)\n",
    "period_ex_iter1 = periodoDeF(a_ex_iter1, N_ex_iter1, powers_ex_iter1)\n",
    "print(f\"\\nPara N={N_ex_iter1}, a={a_ex_iter1} (iterativo paso a paso), el periodo es: {period_ex_iter1}\")\n",
    "# computeAndDrawPowersIterativeStepByStep(a_ex_iter1, N_ex_iter1) # Gráfica densa\n",
    "\n",
    "# N=371, a=6\n",
    "N_ex_iter2 = 371\n",
    "a_ex_iter2 = 6\n",
    "powers_ex_iter2 = powersAModuloNIterativeStepByStep(a_ex_iter2, N_ex_iter2)\n",
    "period_ex_iter2 = periodoDeF(a_ex_iter2, N_ex_iter2, powers_ex_iter2)\n",
    "print(f\"Para N={N_ex_iter2}, a={a_ex_iter2} (iterativo paso a paso), el periodo es: {period_ex_iter2}\")\n",
    "# computeAndDrawPowersIterativeStepByStep(a_ex_iter2, N_ex_iter2) # Gráfica densa"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Encontrando el Periodo de $f_{a,N}$\n",
    "\n",
    "El **periodo** de la función $f_{a,N}(x) = a^x \\pmod N$ es el menor entero positivo $r$ tal que $a^r \\equiv 1 \\pmod N$.\n",
    "Un teorema de la teoría de números (Teorema de Euler) garantiza que si $a$ y $N$ son coprimos, tal $r$ existe y $r < N$ (de hecho, $r$ divide a $\\phi(N)$, donde $\\phi$ es la función totiente de Euler).\n",
    "Una vez que $f_{a,N}(r)=1$, la secuencia de valores se repite: $f_{a,N}(x+r) = a^{x+r} \\pmod N = (a^x \\cdot a^r) \\pmod N = (a^x \\cdot 1) \\pmod N = a^x \\pmod N = f_{a,N}(x)$.\n",
    "\n",
    "La parte cuántica del algoritmo de Shor es un método eficiente para encontrar este periodo $r$. La parte clásica, que estamos discutiendo aquí, asume que $r$ ya ha sido encontrado.\n",
    "\n",
    "**Ejemplo del notebook (N=371, a=6):**\n",
    "Usando `periodoDeF(a, N)` (que internamente usa `powersAModuloN` o `powersAModuloNIterativeStepByStep`), se encuentra que el periodo de $f_{6,371}(x)$ es $r=66$."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Ejemplo de uso de periodoDeF (ya definida anteriormente)\n",
    "N_period_ex = 371\n",
    "a_period_ex = 6\n",
    "\n",
    "# Se puede pasar la lista de potencias precalculada para eficiencia si ya se tiene\n",
    "# powers_list_period_ex = powersAModuloN(a_period_ex, N_period_ex)\n",
    "# period_val = periodoDeF(a_period_ex, N_period_ex, powers_list_period_ex)\n",
    "\n",
    "# O calcularla internamente (menos eficiente si se llama múltiples veces sin precalcular)\n",
    "period_val = periodoDeF(a_period_ex, N_period_ex) \n",
    "print(f\"\\nPara N={N_period_ex}, a={a_period_ex}, el periodo es: {period_val}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Del Periodo a los Factores\n",
    "\n",
    "Una vez que se ha encontrado el periodo $r$, se siguen estos pasos:\n",
    "\n",
    "1.  **Verificar si $r$ es par.** Si $r$ es impar, se debe elegir otro valor de $a$ y reiniciar el proceso de búsqueda del periodo.\n",
    "2.  **Verificar una condición adicional.** Si $r$ es par, se calcula $y = a^{r/2} \\pmod N$. Si $y \\equiv -1 \\pmod N$ (es decir, $y \\equiv N-1 \\pmod N$), entonces también se debe elegir otro valor de $a$ y reiniciar.\n",
    "3.  **Calcular los factores.** Si $r$ es par y $a^{r/2} \\not\\equiv -1 \\pmod N$, entonces los factores de $N$ se pueden encontrar.\n",
    "    Sabemos que $a^r \\equiv 1 \\pmod N$.\n",
    "    Esto implica que $a^r - 1 \\equiv 0 \\pmod N$, lo que significa que $N$ divide a $a^r - 1$.\n",
    "    Como $r$ es par, podemos escribir $a^r - 1 = (a^{r/2})^2 - 1^2$. Esto es una diferencia de cuadrados:\n",
    "    $a^r - 1 = (a^{r/2} - 1)(a^{r/2} + 1)$.\n",
    "    Entonces, $N$ divide al producto $(a^{r/2} - 1)(a^{r/2} + 1)$.\n",
    "    Esto no significa que $N$ divida a cada factor individualmente, pero sí que los factores de $N$ están \"repartidos\" entre $(a^{r/2} - 1)$ y $(a^{r/2} + 1)$.\n",
    "    Los factores no triviales de $N$ se pueden obtener calculando:\n",
    "    * $p' = GCD(a^{r/2} - 1, N)$\n",
    "    * $q' = GCD(a^{r/2} + 1, N)$\n",
    "\n",
    "    Al menos uno de $p'$ o $q'$ será un factor no trivial de $N$ (es decir, diferente de $1$ y $N$), siempre que $a^{r/2} \\not\\equiv 1 \\pmod N$ (lo cual está implícito si $r$ es el *menor* periodo) y $a^{r/2} \\not\\equiv -1 \\pmod N$ (la condición que verificamos).\n",
    "\n",
    "La función `gcd(a, b)` en el notebook implementa el algoritmo de Euclides para encontrar el Máximo Común Divisor.\n",
    "\n",
    "**Ejemplo del notebook (N=371, a=24):**\n",
    "* $N=371, a=24$.\n",
    "* Se encuentra el periodo $r=78$.\n",
    "* $r$ es par. $r/2 = 39$.\n",
    "* Se calcula $a^{r/2} \\pmod N = 24^{39} \\pmod{371}$. El notebook muestra que esto es $160$.\n",
    "    * $24^{39} \\equiv 160 \\pmod{371}$.\n",
    "* Verificar la condición: $160 \\not\\equiv -1 \\pmod{371}$ (ya que $-1 \\pmod{371} \\equiv 370 \\pmod{371}$). La condición se cumple.\n",
    "* Calcular factores:\n",
    "    * $p' = GCD(a^{r/2} - 1, N) = GCD(160 - 1, 371) = GCD(159, 371) = 53$.\n",
    "    * $q' = GCD(a^{r/2} + 1, N) = GCD(160 + 1, 371) = GCD(161, 371) = 7$.\n",
    "* Los factores encontrados son $53$ y $7$. (Verificación: $7 \\times 53 = 371$).\n",
    "\n",
    "**Ejercicio (resuelto): Calcular los factores de $N=247$ usando $a=2$**\n",
    "\n",
    "El objetivo es encontrar los factores de $N=247$ siguiendo los pasos del algoritmo de Shor (la parte clásica, una vez que se conoce el periodo).\n",
    "\n",
    "**Paso 1: Elegir $a$ y verificar que $GCD(a,N)=1$.**\n",
    "\n",
    "Elegimos $a=2$. $GCD(2, 247) = 1$ (ya que 247 es impar).\n",
    "\n",
    "**Paso 2: Encontrar el periodo $r$ de la función $f_{a,N}(x) = a^x \\pmod N$.**\n",
    "\n",
    "Buscamos el menor entero positivo $r$ tal que $2^r \\equiv 1 \\pmod{247}$.\n",
    "Sabiendo que $247 = 13 \\times 19$:\n",
    "* Orden de $2 \\pmod{13}$ es $12$ ($2^{12} \\equiv 1 \\pmod{13}$).\n",
    "* Orden de $2 \\pmod{19}$ es $18$ ($2^{18} \\equiv 1 \\pmod{19}$).\n",
    "El periodo $r = lcm(12, 18) = 36$.\n",
    "\n",
    "**Paso 3: Verificar si $r$ es par y si $a^{r/2} \\not\\equiv -1 \\pmod N$.**\n",
    "\n",
    "El periodo $r=36$ es par. $r/2 = 18$.\n",
    "Calculamos $a^{r/2} \\pmod N = 2^{18} \\pmod{247}$.\n",
    "$2^{18} \\equiv (2^9)^2 \\equiv (512)^2 \\pmod{247}$.\n",
    "$512 = 2 \\times 247 + 18 \implies 2^9 \\equiv 18 \\pmod{247}$.\n",
    "$2^{18} \\equiv 18^2 = 324 \\pmod{247}$.\n",
    "$324 = 1 \\times 247 + 77 \implies 2^{18} \\equiv 77 \\pmod{247}$.\n",
    "Verificamos la condición: $77 \\not\\equiv -1 \\pmod{247}$ (ya que $-1 \\pmod{247} \\equiv 246 \\pmod{247}$). La condición se cumple.\n",
    "\n",
    "**Paso 4: Calcular los factores.**\n",
    "\n",
    "$p' = GCD(a^{r/2} - 1, N) = GCD(77 - 1, 247) = GCD(76, 247) = 19$.\n",
    "$q' = GCD(a^{r/2} + 1, N) = GCD(77 + 1, 247) = GCD(78, 247) = 13$.\n",
    "\n",
    "**Conclusión del ejercicio:**\n",
    "Los factores de $N=247$ encontrados son $19$ y $13$."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import math # Para math.gcd\n",
    "\n",
    "# Definición de custom_gcd (Algoritmo de Euclides) por si math.gcd no estuviera disponible\n",
    "def custom_gcd(a, b):\n",
    "    while b:\n",
    "        a, b = b, a % b\n",
    "    return abs(a) # gcd es no-negativo\n",
    "\n",
    "# Usaremos math.gcd que es estándar en Python 3.5+\n",
    "# from math import gcd # Esta es la forma de importar si solo se quiere gcd\n",
    "\n",
    "# Funciones para encontrar el periodo ya definidas: \n",
    "# powersAModuloN(a, N) o powersAModuloNIterativeStepByStep(a,N)\n",
    "# periodoDeF(a, N, powers_list=None)\n",
    "\n",
    "def factor_from_period(N, a):\n",
    "    \"\"\"Intenta factorizar N usando el periodo de a mod N.\"\"\"\n",
    "    print(f\"\\nIntentando factorizar N={N} usando a={a}\")\n",
    "    \n",
    "    # Paso 0: Verificar coprimalidad de a y N\n",
    "    common_divisor = math.gcd(a, N)\n",
    "    if common_divisor != 1:\n",
    "        print(f\"GCD(a, N) = {common_divisor} != 1. Factor encontrado directamente: {common_divisor}\")\n",
    "        if N // common_divisor != 1:\n",
    "             print(f\"El otro factor es {N // common_divisor}\")\n",
    "        return common_divisor, N // common_divisor if N // common_divisor != 1 else None\n",
    "\n",
    "    # Paso 1: Encontrar el periodo r (usando las funciones clásicas aquí)\n",
    "    # Nota: En el algoritmo de Shor completo, esto se haría con un ordenador cuántico.\n",
    "    # Usaremos la función más eficiente definida anteriormente: powersAModuloN\n",
    "    powers_list = powersAModuloN(a, N) \n",
    "    r = periodoDeF(a, N, powers_list)\n",
    "    print(f\"Periodo r encontrado: {r}\")\n",
    "\n",
    "    if r == -1:\n",
    "        print(\"No se pudo encontrar el periodo (puede que 'a' no sea un buen candidato o N sea problemático).\")\n",
    "        return None, None\n",
    "    if r % 2 != 0:\n",
    "        print(f\"El periodo r={r} es impar. Se necesita otro 'a'.\")\n",
    "        return None, None\n",
    "\n",
    "    # Paso 2: Calcular y = a^(r/2) mod N\n",
    "    # Usar r // 2 para división entera\n",
    "    y = pow(a, r // 2, N)\n",
    "    print(f\"y = a^(r/2) mod N = {a}^({r//2}) mod {N} = {y}\")\n",
    "\n",
    "    if y == (N - 1):\n",
    "        print(f\"y = {y} es congruente con -1 mod N (o sea, y = N-1). Se necesita otro 'a'.\")\n",
    "        return None, None\n",
    "    # Esta condición también es importante, si y=1, los factores serán triviales 1 y N\n",
    "    if y == 1: \n",
    "        print(f\"y = {y} es congruente con 1 mod N. Los factores serán triviales (1 y N). Se necesita otro 'a'.\")\n",
    "        return None, None\n",
    "\n",
    "    # Paso 3: Calcular factores\n",
    "    factor1 = math.gcd(y - 1, N)\n",
    "    factor2 = math.gcd(y + 1, N)\n",
    "    \n",
    "    print(f\"Factor candidato 1 (GCD(y-1, N)) = GCD({y-1}, {N}) = {factor1}\")\n",
    "    print(f\"Factor candidato 2 (GCD(y+1, N)) = GCD({y+1}, {N}) = {factor2}\")\n",
    "\n",
    "    found_factors = []\n",
    "    if factor1 != 1 and factor1 != N:\n",
    "        print(f\"Factor no trivial encontrado: {factor1}\")\n",
    "        found_factors.append(factor1)\n",
    "    if factor2 != 1 and factor2 != N:\n",
    "        print(f\"Factor no trivial encontrado: {factor2}\")\n",
    "        found_factors.append(factor2)\n",
    "        \n",
    "    # Asegurarse de que los factores multiplicados den N y son distintos\n",
    "    if len(found_factors) == 2 and found_factors[0] * found_factors[1] == N and found_factors[0] != found_factors[1]:\n",
    "        return tuple(sorted(found_factors))\n",
    "    elif len(found_factors) == 1:\n",
    "        # Si solo se encontró un factor, el otro es N/factor\n",
    "        other_factor = N // found_factors[0]\n",
    "        if found_factors[0] * other_factor == N:\n",
    "             return tuple(sorted((found_factors[0], other_factor)))\n",
    "    \n",
    "    print(\"No se encontraron factores no triviales con este 'a' o los factores son N y 1.\")\n",
    "    return None, None\n",
    "\n",
    "# Ejemplo del notebook: N=371, a=24\n",
    "N_factor_ex1 = 371\n",
    "a_factor_ex1 = 24\n",
    "factors1 = factor_from_period(N_factor_ex1, a_factor_ex1)\n",
    "if factors1[0] and factors1[1]:\n",
    "    print(f\"Factores de {N_factor_ex1}: {factors1[0]} y {factors1[1]}\")\n",
    "    print(f\"Verificación: {factors1[0]} * {factors1[1]} = {factors1[0] * factors1[1]}\")\n",
    "\n",
    "# Ejercicio resuelto: N=247, a=2\n",
    "N_factor_ex2 = 247\n",
    "a_factor_ex2 = 2\n",
    "factors2 = factor_from_period(N_factor_ex2, a_factor_ex2)\n",
    "if factors2[0] and factors2[1]:\n",
    "    print(f\"Factores de {N_factor_ex2}: {factors2[0]} y {factors2[1]}\")\n",
    "    print(f\"Verificación: {factors2[0]} * {factors2[1]} = {factors2[0] * factors2[1]}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## El Algoritmo Cuántico\n",
    "\n",
    "La parte verdaderamente \"cuántica\" del algoritmo de Shor es el **subrutina de búsqueda del periodo**. La descripción en el notebook es breve pero capta la esencia.\n",
    "\n",
    "Se necesitan dos registros de qubits:\n",
    "1.  Un registro de entrada (o primer registro) con $m$ qubits.\n",
    "2.  Un registro de salida (o segundo registro) con $n$ qubits, donde $n = \\lceil \\log_2 N \\rceil$ (el número de bits necesarios para representar $N$).\n",
    "\n",
    "El valor de $m$ debe ser lo suficientemente grande para obtener una buena estimación del periodo $r$. A menudo se elige $m \\approx 2n$, de modo que $2^m \\approx N^2$.\n",
    "\n",
    "**Pasos conceptuales del circuito cuántico:**\n",
    "\n",
    "1.  **Inicialización:**\n",
    "    Se comienza con ambos registros en el estado $\\ket{0}$:\n",
    "    $\\ket{\\psi_0} = \\ket{\\boldsymbol{0_m}, \\boldsymbol{0_n}} = \\ket{0}^{\\otimes m} \\ket{0}^{\\otimes n}$\n",
    "\n",
    "2.  **Superposición en el primer registro:**\n",
    "    Se aplica una compuerta Hadamard a cada qubit del primer registro. Esto crea una superposición uniforme de todos los posibles valores de $x$ (desde $0$ hasta $2^m-1$):\n",
    "    $\\ket{\\psi_1} = \\frac{1}{\\sqrt{2^m}} \\sum_{x=0}^{2^m-1} \\ket{x} \\ket{\\boldsymbol{0_n}}$\n",
    "\n",
    "3.  **Cálculo de la función modular (Oráculo):**\n",
    "    Se aplica una operación unitaria $U_f$ que calcula $f_{a,N}(x) = a^x \\pmod N$ y almacena el resultado en el segundo registro. Esta es la parte más compleja de construir en un computador cuántico real (exponenciación modular cuántica).\n",
    "    $\\ket{\\psi_2} = U_f \\ket{\\psi_1} = \\frac{1}{\\sqrt{2^m}} \\sum_{x=0}^{2^m-1} \\ket{x} \\ket{a^x \\pmod N}$\n",
    "\n",
    "4.  **Medición del segundo registro:**\n",
    "    Se mide el segundo registro. Supongamos que se obtiene un valor $k = a^{x_0} \\pmod N$ (donde $x_0$ es uno de los valores de $x$ que producen $k$).\n",
    "    Debido a la periodicidad de $f_{a,N}$, todos los estados $\\ket{x}$ que producen el mismo resultado $k$ son $x_0, x_0+r, x_0+2r, \\dots$.\n",
    "    Después de la medición, el primer registro colapsa a una superposición de solo estos valores de $x$:\n",
    "    $\\ket{\\psi_3} \\propto \\sum_{j=0}^{\\lfloor (2^m-1-x_0)/r \\rfloor} \\ket{x_0 + jr}$\n",
    "    Este estado es periódico en $x$ con periodo $r$.\n",
    "\n",
    "5.  **Transformada de Fourier Cuántica Inversa (QFT$^{\\dagger}$):**\n",
    "    Se aplica la QFT$^{\\dagger}$ al primer registro. La QFT transforma estados con periodicidad $r$ en estados donde los picos de probabilidad ocurren en múltiplos de $2^m/r$.\n",
    "    $\\ket{\\psi_4} = \\text{QFT}^{\\dagger} \\ket{\\psi_3}$\n",
    "\n",
    "6.  **Medición del primer registro:**\n",
    "    Se mide el primer registro. El resultado de la medición, digamos $c$, tendrá una alta probabilidad de ser un múltiplo entero de $2^m/r$:\n",
    "    $c \\approx \\frac{k \\cdot 2^m}{r}$ para algún entero $k$.\n",
    "    Por lo tanto, $\\frac{c}{2^m} \\approx \\frac{k}{r}$.\n",
    "\n",
    "7.  **Estimación clásica de $r$:**\n",
    "    La fracción $c/2^m$ es una aproximación de $k/r$. Se utiliza el algoritmo de fracciones continuas para encontrar la fracción irreducible $k'/r'$ que mejor se aproxima a $c/2^m$. El denominador $r'$ es un candidato para el periodo $r$ (o un factor de $r$). Se realizan varias pruebas para confirmar si $r'$ es el periodo $r$ correcto (por ejemplo, verificando si $a^{r'} \\equiv 1 \\pmod N$). Si no, se repiten los pasos cuánticos o se prueban múltiplos de $r'$.\n",
    "\n",
    "*(Nota: El notebook original menciona una imagen `images/shoralgorithm.jpg` que no se puede incrustar directamente aquí, pero ilustraría el circuito cuántico general.)*"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Resumen de los Pasos del Algoritmo de Shor (según el notebook):\n",
    "\n",
    "**Entrada:** Un entero positivo $N$.\n",
    "**Salida:** Un factor $p$ de $N$.\n",
    "\n",
    "1.  **Paso 1 (Clásico):** Determinar si $N$ es primo o una potencia de un primo. Si es así, declararlo y salir. (Existen algoritmos clásicos eficientes para esto).\n",
    "2.  **Paso 2 (Clásico):** Elegir aleatoriamente un entero $a$ tal que $1 < a < N$. Calcular $GCD(a, N)$. Si $GCD(a, N) \\neq 1$, entonces $GCD(a,N)$ es un factor. Devolverlo y salir.\n",
    "3.  **Paso 3 (Cuántico):** Usar el circuito cuántico (como el descrito arriba) para encontrar el periodo $r$ de $a^x \\pmod N$.\n",
    "4.  **Paso 4 (Clásico):** Si $r$ es impar, o si $a^{r/2} \\equiv -1 \\pmod N$, entonces volver al Paso 2 y elegir otro $a$.\n",
    "5.  **Paso 5 (Clásico):** Calcular $p' = GCD(a^{r/2} - 1, N)$ y $q' = GCD(a^{r/2} + 1, N)$. Devolver al menos una de las soluciones no triviales."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Lecturas Adicionales\n",
    "\n",
    "El notebook sugiere las siguientes referencias para profundizar:\n",
    "\n",
    "* Yanofsky, Noson S.; Mannucci, Mirco A.. *Quantum Computing for Computer Scientists*.\n",
    "* Nielsen, M. A., & Chuang, I. L. (2010). *Quantum Computation and Quantum Information*.\n",
    "* Kaye, P., Laflamme, R., & Mosca, M. (2007). *An Introduction to Quantum Computing*.\n",
    "* [Documentación de Qiskit](https://qiskit.org/documentation/)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
